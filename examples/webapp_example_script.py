#!/usr/bin/env python3
# SPDX-FileCopyrightText: 2021 Daniel Laidig <laidig@control.tu-berlin.de>
#
# SPDX-License-Identifier: MIT
import multiprocessing
import time

import qmt
import numpy as np


def offlineWithDefaultConfig():
    """Simple webapp demo to show how offline playback of data works"""

    # create some quaternion data for testing
    t = qmt.timeVec(T=10, Ts=0.01)
    axis = np.column_stack([np.cos(t), np.zeros_like(t), np.sin(t)])
    quat = qmt.quatFromAngleAxis(np.sin(t), axis)
    data = qmt.Struct(t=t, quat=quat)

    # run webapp
    webapp = qmt.Webapp('/view/imubox', data=data)
    webapp.run()


def offlineWithCustomConfig():
    """
    Example of how to use a config.

    By default, the /view/imubox webapp will detect all signals named "quat" or "quat" + one single letter, and
    visualize them (with the single letter painted on the box). It is also possible to define a custom config that will
    define which data is displayed.
    """

    # create some quaternion data for testing
    t = qmt.timeVec(T=10, Ts=0.01)
    axis = np.column_stack([np.cos(t), np.zeros_like(t), np.sin(t)])
    quat = qmt.quatFromAngleAxis(np.sin(t), axis)
    quat2 = qmt.qinv(quat)
    data = qmt.Struct(t=t, quat1=quat, quat2=quat2)

    # This config tells the webapp how many IMU boxes to create and how the variables are called.
    # Furthermore, we show the first quaternion twice and use a different IMU coordinate system for the second copy A'
    # (x axis pointing forward instead of right). For the last IMU, we enable axis arrows.
    # Markers can be specified to annotate specific parts of the generated data in the playback timeline.
    config = {
        'imus': [
            {'signal': 'quat1', 'letter': 'A'},
            {'signal': 'quat1', 'letter': 'A\'', 'cs': 'FLU'},
            {'signal': 'quat2', 'letter': 'B', 'axes': True},
        ],
        'markers': [{'pos': 4, 'end': 6, 'name': 'example for a range marker'}],
    }

    webapp = qmt.Webapp('/view/imubox', config=config, data=data)
    webapp.run()


def online():
    """
    Simple example for online data processing

    We use a ClockDataSource to generate samples at a fixed interval and create a simple Block class that does the
    online data processing. The ClockDataSource generates samples that only contain the time, but we could also use
    data sources that provide real-time measurement data from IMUs (e.g. via bluetooth).
    """

    class ExampleBlock(qmt.Block):
        def step(self, inputs):
            t = inputs['t']
            axis = [np.cos(t), np.zeros_like(t), np.sin(t)]
            quat = qmt.quatFromAngleAxis(np.sin(t), axis)
            return {'t': t, 'quat': quat.flatten()}

    webapp = qmt.Webapp('/view/imubox')
    webapp.setupOnlineLoop(qmt.ClockDataSource(0.04), ExampleBlock())
    webapp.run()


def onlineDummyImuData():
    """
    Simple example for the dummy IMU data souce

    The DummyImuDataSource generates artificial IMU data. In this example, we just show the quaternions generated by
    the data source, but we could easily add a processing block (like in the example above) to perform custom data
    processing based on the gyroscope, accelerometer, and magnetometer measurements.
    """

    webapp = qmt.Webapp('/view/imubox')
    webapp.setupOnlineLoop(qmt.DummyImuDataSource(0.04, 5))
    # We could also use qmt.dataSourceFromJson to dynamically create the data source from a JSON configuration string.
    # This can be used to allow for loading a data source that accesses real IMU data from external module, and define
    # this module and the necessary parameters via a command line argument.
    # webapp.setupOnlineLoop(qmt.dataSourceFromJson('{"class": "qmt.DummyImuDataSource", "Ts": 0.04, "N": 3}'))
    webapp.run()


def pythonPlayback():
    """
    Example of how to play back existing data from Python

    Unlike the previous offline examples, playback is handed on the Python side and only the current sample is
    transferred via the websocket. This is for example useful to replay experiments in order to create
    high quality videos.

    Note that we can also combine this with online data processing, e.g. to replay a file containing sensor data and
    processing it in real-time.
    """

    # generate .mat file with data for playback
    t = qmt.timeVec(T=10, Ts=0.01)
    axis = np.column_stack([np.cos(t), np.zeros_like(t), np.sin(t)])
    quat = qmt.quatFromAngleAxis(np.sin(t), axis)
    quat2 = qmt.qinv(quat)
    data = qmt.Struct(t=t, quat1=quat, quat2=quat2)
    data.save('example_output/webapp_example_data.mat', makedirs=True)

    config = {
        'imus': [
            {'signal': 'quat1', 'letter': 'A'},
            {'signal': 'quat2', 'letter': 'B'},
        ]
    }

    # let's also save the config to a file. this way, you can test the command line tool:
    # qmt-webapp /view/imubox -d example_output/webapp_example_data.mat -c example_output/webapp_example_config.mat
    qmt.Struct(config).save('example_output/webapp_example_config.mat', makedirs=True)

    webapp = qmt.Webapp('/view/imubox', config=config)
    # Note that saving to a file is not necessary and we can just directly pass the data object.
    # We could also use qmt.PlaybackDataSource to control addtional parameters (e.g. looping).
    webapp.setupOnlineLoop('example_output/webapp_example_data.mat')
    webapp.run()


def interactiveOffline():
    """
    Example for interactive offline batch processing

    With the show_speed_slider option, we tell the visualisation to create a slider. Every time the value is changed,
    we recalculate the whole data and send the new data to the visualization.
    """

    def processData(webapp, params):
        speed = params['speed']
        t = qmt.timeVec(T=10, Ts=0.01)
        axis = np.column_stack([np.cos(speed*t), np.zeros_like(t), np.sin(speed*t)])
        quat = qmt.quatFromAngleAxis(np.sin(speed * t), axis)
        webapp.data = qmt.Struct(t=t, quat=quat)

    config = {'show_speed_slider': True}
    webapp = qmt.Webapp('/view/imubox', config=config)
    webapp.on('params', processData)
    webapp.run()


def interactiveOnline():
    """
    Example for interactive online processing

    With the show_speed_slider option, we tell the visualisation to create a slider. The setParam function of the
    processing block will automatically be called every time the slider value changes.
    """

    class ExampleBlock(qmt.Block):
        def __init__(self):
            super().__init__()
            self.params['speed'] = 1.0

        def step(self, sample):
            t = sample['t']
            speed = self.params['speed']
            axis = [np.cos(speed*t), 0, np.sin(speed*t)]
            quat = qmt.quatFromAngleAxis(np.sin(speed * t), axis)
            return {'t': t, 'quat': quat}

    config = {'show_speed_slider': True}
    webapp = qmt.Webapp('/view/imubox', config=config)
    webapp.setupOnlineLoop(qmt.ClockDataSource(0.04), ExampleBlock())
    webapp.run()


def run(conn, Ts):
    """Target function for the runCalculationsInProcess example."""
    t0 = time.monotonic()
    N = 0
    try:
        while True:
            t = round(N*Ts, 9)
            time.sleep(max(0, t0 + t - time.monotonic()))
            N += 1

            # receive parameters (and commands) from webapp
            speed = conn.getParams().get('speed', 1.0)
            for command in conn.getCommands():
                print('received command:', command)

            # calculate and send sample
            axis = [np.cos(speed * t), 0, np.sin(speed * t)]
            quat = qmt.quatFromAngleAxis(np.sin(speed * t), axis)
            conn.sendSample({'t': t, 'quat': quat})
    except KeyboardInterrupt:
        return  # stop process gracefully


def runCalculationsInProcess():
    """
    Example for interactive online processing in a separate process

    The function run is executed in a separate process via the ProcessDataSource and the multiprocessing package. The
    run function can use a qmt.ProcessDataSourceConnection object to communicate with the webapp. This makes it possible
    to integrate existing code that is written in a blocking way and does not function well in combination with async
    code.
    """

    config = {'show_speed_slider': True}
    webapp = qmt.Webapp('/view/imubox', config=config)
    webapp.setupOnlineLoop(qmt.ProcessDataSource(run, 0.04))
    webapp.run()


def runWebappInProcess():
    """
    Example for running the webapp in a separate process

    This example works similar to ProcessDataSource example, but instead of starting a blocking data processing function
    in a new process, the Webapp is started in a separate process. A similar conn object is returned which can be used
    to communicate with the webapp..
    """

    config = {'show_speed_slider': True}
    webapp = qmt.Webapp('/view/imubox', config=config)
    conn = webapp.runInProcess()

    t0 = time.monotonic()
    Ts = 0.04
    N = 0
    while True:
        t = round(N * Ts, 9)
        time.sleep(max(0.0, t0 + t - time.monotonic()))
        N += 1

        # receive parameters (and commands) from webapp
        speed = conn.getParams().get('speed', 1.0)
        for command in conn.getCommands():
            print('received command:', command)
        if conn.isClosed():
            print('the webapp window was closed')
            break
        # if t == 10:  # note: we can also close the webapp by calling shutdown()
        #     conn.shutdown()

        # calculate and send sample
        axis = [np.cos(speed * t), 0, np.sin(speed * t)]
        quat = qmt.quatFromAngleAxis(np.sin(speed * t), axis)
        conn.sendSample({'t': t, 'quat': quat})


def runExample(f):
    """Prints the docstring of the function and then runs it."""
    from textwrap import dedent
    print(f'\n{f.__name__}: {dedent(f.__doc__)}\n')
    f()


if __name__ == '__main__':
    # Note: If PySide has already been used in the main process (e.g., by running a Webapp or by creating plots with
    # matplotlib and the Qt5Agg backend), the `spawn` method has to be selected before calling runInProcess().
    # With the `fork` method, the child process will inherit the singleton QApplication instance from the main process.
    multiprocessing.set_start_method('spawn')

    runExample(offlineWithDefaultConfig)
    runExample(offlineWithCustomConfig)
    runExample(online)
    runExample(onlineDummyImuData)
    runExample(pythonPlayback)
    runExample(interactiveOffline)
    runExample(interactiveOnline)
    runExample(runCalculationsInProcess)
    runExample(runWebappInProcess)
